//输入图的邻接矩阵，两顶点没有直接路径的置为0

#include<stdio.h>
#define Vertexnum 7//点的个数可以自己定义
int used[Vertexnum+1];
int s;//
int counter=1;//计算从以x[1]为起点的总的哈密顿环路

int path_ok(int adj[][Vertexnum+1],int k,int x[])
{
if(used[x[k]])
   return false;
if(k<Vertexnum)
   return adj[x[k-1]][x[k]];
else
   return adj[x[Vertexnum-1]][x[Vertexnum]]&&adj[x[1]][x[Vertexnum]];
}

bool rehamilton(int adj[][Vertexnum+1],int k,int x[])
{
for( x[k]=1;x[k]<=Vertexnum;x[k]++)
   if(path_ok(adj,k,x))
   {
    used[x[k]]=true;
      if(k==Vertexnum||rehamilton(adj,k+1,x))
    {
     printf("begin Case %-2d: %d",counter++,x[1]);//输出一个哈密顿环路
    
     for(int i=2;i<=Vertexnum;i++)
     
      printf("=> %d",x[i]);
     printf("=>%d\n",x[1]);
   
    }
    used[x[k]]=false;
   }
   return false;
}
void hamilton(int adj[][Vertexnum+1],int x[])
{
int t=2;
for( s=1;s<=Vertexnum;s++)
{

for(int i=1;i<=Vertexnum;i++)

   used[i]=false;

    x[1]=s;//从s出发

used[x[1]]=true;
     
rehamilton(adj,2,x);
}
}

int main()
{
int i,j,adj[Vertexnum+1][Vertexnum+1],x[Vertexnum+1];
for(i=1;i<=Vertexnum;i++)
{
   for(j=1;j<=Vertexnum;j++)
    scanf("%d",&adj[i][j]);//输入邻接矩阵
}

   hamilton(adj,x);
   printf("END\n");
   return 0;
}
